import json
import os

import requests_cache
import pandas as pd
from retry_requests import retry

import openmeteo_requests

from kopenai import KOpenAI
from kvalidate import check_param_empty, check_param_none


class KWeatherChat(KOpenAI):
    def __init__(self, model: str = 'gpt-3.5-turbo', messages: list = None):
        super().__init__(model=model, messages=messages)
        self.set_openmeteo_client()
        self.set_latest_function_defs()

    def set_openmeteo_client(self):
        cache_session = requests_cache.CachedSession('.cache', expire_after = -1)
        retry_session = retry(cache_session, retries = 5, backoff_factor = 0.2)
        self.openmeteo = openmeteo_requests.Client(session = retry_session)

    def set_latest_function_defs(self):
        with open('./prompts/functions/hist_weather.json') as f:
            pnf = json.load(f)
            pnf = [p for p in pnf if p['function']['name'] == 'weather_api'][0]

            prompt = pnf['prompt']
            self.functions = [pnf['function']]

        if not len(self.messages):
            super().set_system_prompt(prompt)

    def extract_df_from_response(self, params, key, responses):
        """
        response_vars represents either response.Daily() or response.Hourly()
        """
        response = responses[0]
        response_vars = response.Daily() if key == 'daily' else response.Hourly()

        data = {"date": pd.date_range(
	        start = pd.to_datetime(response_vars.Time(), unit = "s"),
	        end = pd.to_datetime(response_vars.TimeEnd(), unit = "s"),
	        freq = pd.Timedelta(seconds = response_vars.Interval()),
	        inclusive = "left"
        )}

        for i in range(response_vars.VariablesLength()):
            data[params[key][i]] = response_vars.Variables(i).ValuesAsNumpy()
        return pd.DataFrame(data)

    def weather_api(self, params):
        """
        with params generated by an llm, call the openmeteo api
        """
        url = "https://archive-api.open-meteo.com/v1/archive"
        responses = self.openmeteo.weather_api(url, params=params)

        ret = {}
        if not check_param_empty(params, 'daily'):
            ret['daily'] = self.extract_df_from_response(params, 'daily', responses)

        if not check_param_empty(params, 'hourly'):
            ret['hourly'] = self.extract_df_from_response(params, 'hourly', responses)

        return ret

    def chat(self, message, role: str = 'user', foff=False, function_call=None):
        """
        foff=True means functions will not be passed to chat, this reducing the number of tokens passed to openai
        """
        if not foff:
            fn_call = super().chat(message, role=role, functions=self.functions, function_call=function_call)
        else:
            fn_call = super().chat(message, role=role)

        if not check_param_none(fn_call, 'function_call'):
            if fn_call['function_call']['name'] == 'weather_api':
                params = json.loads(fn_call['function_call']['arguments'])
                print('params extracted:', params)

                return self.weather_api(params)
        return fn_call


def main():
    kwc = KWeatherChat()
    df = kwc.chat('what was the average hourly temperatures, precipitation from 2022 oct 30 to 2023 oct 31 in chicago')['hourly']
    df.to_csv('./chicago_weather.csv')

